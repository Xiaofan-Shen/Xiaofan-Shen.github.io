<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-03T01:07:40+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">FAN Bot</title><subtitle>your web description</subtitle><author><name>true</name></author><entry><title type="html">Particle Filter Implemented in Python</title><link href="http://localhost:4000/2024/08/03/Particle-filter-in-Python.html" rel="alternate" type="text/html" title="Particle Filter Implemented in Python" /><published>2024-08-03T01:00:00+01:00</published><updated>2024-08-03T01:00:00+01:00</updated><id>http://localhost:4000/2024/08/03/Particle%20filter%20in%20Python</id><content type="html" xml:base="http://localhost:4000/2024/08/03/Particle-filter-in-Python.html"><![CDATA[<h1 id="particle--filters-implemented-in-object-tracking">Particle  Filters implemented in Object tracking</h1>

<h3 id="whats-paricle-filters">What’s Paricle filters?</h3>

<p>Particle filter is a powerful technique used for state estimation, particularly effective in handling nonlinear systems, non-Gaussian distributions, and complex noise scenarios. It utilizes a large number of randomly sampled particles to represent the distribution of possible system states and dynamically updates their weights based on sensor measurements. Unlike traditional filters such as the Kalman filter, particle filter is not constrained by assumptions of linearity and Gaussianity, making it ideal for scenarios with multimodal distributions, unknown dynamic models, or nonlinear sensor measurements.</p>

<p>For example, in robot localization, particle filter excels in accurately tracking the robot’s position and orientation amidst challenging environments and unpredictable motion patterns. This versatility makes particle filter a crucial tool in tasks like robot navigation, target tracking, and other dynamic system state estimations.</p>

<p>In this example, we will apply it into the tracking of dog’s postion.
The original video:</p>
<iframe type="text/html" width="100%" height="385" src="https://www.youtube.com/embed/1LYmxfMimBQ" frameborder="0"></iframe>

<p><strong>The performance</strong>:</p>

<p>The video features a running dog being tracked using a particle filter. The red box represents the position predicted by the particle with the highest weight, indicating the most likely position of the dog. The green box represents the weighted average position of all particles, providing an overall estimate by combining the predictions of all particles. This dual-box system helps in accurately tracking the dog’s movement amidst challenging and dynamic environments.</p>
<iframe type="text/html" width="100%" height="385" src="https://www.youtube.com/embed/bl6VRCHkETI" frameborder="0"></iframe>

<p><strong>Steps of particle filter</strong></p>

<p>The core idea behind particle filtering is to use a large number of random samples (particles) to represent the distribution of possible states in a system, allowing for estimation and prediction of the system’s state. To apply this algorithm, there are few steps to follow:</p>

<ol>
  <li>
    <p><strong>Initialization</strong></p>

    <p>Randomly generate a set of particles and assign equal weights to them. These particles represent possible initial states of the system.</p>
  </li>
  <li>
    <p><strong>Prediction</strong></p>

    <p>For each particle, use the system dynamics model and control inputs to predict the next state. This involves moving the particles according to the expected system behavior.</p>
  </li>
  <li>
    <p><strong>Update (Weighting)</strong></p>

    <p>Update the weight of each particle based on the likelihood of the observed measurements given the particle’s predicted state. Particles that better match the actual observations receive higher weights.</p>
  </li>
  <li>
    <p><strong>Resample</strong></p>

    <p>Resample the particles based on their weights to focus on more probable states. Particles with higher weights are more likely to be duplicated, while particles with lower weights are likely to be discarded.</p>
  </li>
  <li>
    <p><strong>Compute Estimation</strong></p>

    <p>Optionally, compute the state estimate from the weighted particles, typically using the weighted mean or mode of the particles.</p>
  </li>
  <li>
    <p><strong>Loop</strong></p>

    <p>Repeat the prediction, update, resampling, and estimation steps for each new observation.</p>
  </li>
</ol>

<h3 id="code-implementation">Code Implementation</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">cv2</span>
</code></pre></div></div>

<h3 id="1-state-prediction">1. State Prediction</h3>
<p>The state of each particle is predicted based on a state transition model, which is often a linear model with added Gaussian noise.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_of_particles</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">s_init</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1600</span><span class="p">,</span> <span class="mi">700</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># Initial state [x_center, y_center, x_velocity, y_velocity]
</span>
<span class="c1"># For the first frame, all particles are initialized to the same state
</span><span class="n">s_new</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">tile</span><span class="p">(</span><span class="n">s_init</span><span class="p">,</span> <span class="p">(</span><span class="n">num_of_particles</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">T</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">num_of_particles</span><span class="p">)</span>
</code></pre></div></div>

<p>Where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">s_init</code>represents the initial state of the target, including its center position and velocity.</li>
  <li><code class="language-plaintext highlighter-rouge">s_new</code> initializes the particle states by replicating s_init.</li>
  <li><code class="language-plaintext highlighter-rouge">weights</code> initializes all particle weights to 1.</li>
</ul>

<h3 id="2-predict-particle-states">2. Predict Particle States</h3>
<p>Particles are predicted based on a state transition model. This model is linear and includes Gaussian noise to simulate process uncertainty.</p>

\[x_t^{(i)} = A \cdot x_{t-1}^{(i)} + v_t^{(i)}\]

<p><strong>Where:</strong></p>
<ul>
  <li>$x_t^{(i)}$  is the state of the (i)-th particle at time (t).</li>
  <li>$A$  is the state transition matrix.</li>
  <li>$v_t^{(i)}$ is the process noise for the (i)-th particle at time (t).</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">predict_particles</span><span class="p">(</span><span class="n">particles_states</span><span class="p">):</span>
    <span class="n">dynamics</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span>
        <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="p">)</span>
    <span class="n">predicted_states</span> <span class="o">=</span> <span class="n">dynamics</span> <span class="o">@</span> <span class="n">particles_states</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">particles_states</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">predicted_states</span>
</code></pre></div></div>

<p>Where:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dynamics</code> is the state transition matrix A, which includes the transition model for position and velocity.</li>
  <li><code class="language-plaintext highlighter-rouge">np.random.normal</code> adds Gaussian noise to the predicted states.</li>
</ul>

<h3 id="3-compute-particle-weights">3. Compute Particle Weights</h3>
<p>Weights are computed based on the likelihood of the observed data given the particle’s state. This is done by comparing the histogram of the particle’s state with the reference histogram.</p>

<p>Weight calculation formula:</p>

\[w_t^{(i)} \propto p(y_t | x_t^{(i)})\]

<p><strong>Where:</strong>
 \(p(y_t | x_t^{(i)})\) is the likelihood of the observation given the particle’s state.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compute_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="p">.</span><span class="nf">isclose</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">p histogram is not normalized</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="p">.</span><span class="nf">isclose</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">q histogram is not normalized</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">q</span><span class="p">))</span>  <span class="c1"># Bhattacharyya coefficient
</span>    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="mi">20</span> <span class="o">*</span> <span class="n">bc</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Compute the histogram:
\(\text{hist}, \_ = \text{np.histogram}(\text{roi\_indexing}, \text{bins}=4096, \text{range}=(0, 4096))\)</p>
  </li>
  <li>
    <p>Normalize the histogram:</p>
  </li>
</ul>

<p>\(\text{norm\_hist} = \frac{\text{hist}}{\sum \text{hist}}\)
<strong>Where:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">roi_indexing</code> represents quantized color values from the ROI.</li>
</ul>

<h3 id="4-compute-normalized-histogram">4. Compute Normalized Histogram</h3>

<p>Extract the region of interest (ROI) from the image based on the particle’s state and compute its color histogram. Normalize the histogram for comparison.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compute_norm_hist</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_width</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_height</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_height</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">roi</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">roi_reduced</span> <span class="o">=</span> <span class="n">roi</span> <span class="o">//</span> <span class="mi">16</span>
    <span class="n">roi_reduced</span> <span class="o">=</span> <span class="n">roi_reduced</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">roi_indexing</span> <span class="o">=</span> <span class="p">(</span><span class="n">roi_reduced</span><span class="p">[...,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">roi_reduced</span><span class="p">[...,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">roi_reduced</span><span class="p">[...,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">flatten</span><span class="p">()</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">histogram</span><span class="p">(</span><span class="n">roi_indexing</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4096</span><span class="p">))</span>
    <span class="n">norm_hist</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">norm_hist</span>
</code></pre></div></div>

<p>Where:</p>
<ul>
  <li>Extract the ROI based on the particle’s state and the bounding box dimensions.</li>
  <li>Quantize color values to create a histogram hist.</li>
  <li>norm_hist is the normalized histogram.</li>
</ul>

<h3 id="5-resample-particles">5. Resample Particles</h3>
<p>Resampling is done based on particle weights. This step ensures that particles with higher weights are more likely to be selected.
Resampling steps:</p>
<ul>
  <li>Calculate the cumulative distribution function (CDF) of the weights.</li>
  <li>Use random numbers to sample indices according to the CDF.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sample_particle</span><span class="p">(</span><span class="n">particles_states</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="n">normalized_weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">sampling_weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">cumsum</span><span class="p">(</span><span class="n">normalized_weights</span><span class="p">)</span>
    <span class="n">rand_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">random</span><span class="p">(</span><span class="n">sampling_weights</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">cross_diff</span> <span class="o">=</span> <span class="n">sampling_weights</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">rand_numbers</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="n">cross_diff</span><span class="p">[</span><span class="n">cross_diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span>
    <span class="n">sampling</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmin</span><span class="p">(</span><span class="n">cross_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sampled_particles</span> <span class="o">=</span> <span class="n">particles_states</span><span class="p">[:,</span> <span class="n">sampling</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sampled_particles</span>
</code></pre></div></div>

<p>Where:</p>
<ul>
  <li>sampling_weights is the cumulative sum of normalized weights.</li>
  <li>cross_diff is used to match random numbers with the cumulative weights to select particles.</li>
</ul>

<h3 id="6-draw-bounding-box">6. Draw Bounding Box</h3>
<p>Draw bounding boxes around the object based on the weighted average position and the position of the particle with the maximum weight.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_bounding_box</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">with_max</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">mean_box</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">x_c_mean</span><span class="p">,</span> <span class="n">y_c_mean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">mean_box</span><span class="p">[:</span><span class="mi">2</span><span class="p">]).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">image_with_boxes</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
    <span class="n">cv2</span><span class="p">.</span><span class="nf">rectangle</span><span class="p">(</span><span class="n">image_with_boxes</span><span class="p">,</span> <span class="p">(</span><span class="n">x_c_mean</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">y_c_mean</span> <span class="o">-</span> <span class="n">half_height</span><span class="p">),</span>
                                     <span class="p">(</span><span class="n">x_c_mean</span> <span class="o">+</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">y_c_mean</span> <span class="o">+</span> <span class="n">half_height</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">with_max</span><span class="p">:</span>
        <span class="n">max_box</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">weights</span><span class="p">)]</span>
        <span class="n">x_c_max</span><span class="p">,</span> <span class="n">y_c_max</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">max_box</span><span class="p">[:</span><span class="mi">2</span><span class="p">]).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">cv2</span><span class="p">.</span><span class="nf">rectangle</span><span class="p">(</span><span class="n">image_with_boxes</span><span class="p">,</span> <span class="p">(</span><span class="n">x_c_max</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">y_c_max</span> <span class="o">-</span> <span class="n">half_height</span><span class="p">),</span>
                                         <span class="p">(</span><span class="n">x_c_max</span> <span class="o">+</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">y_c_max</span> <span class="o">+</span> <span class="n">half_height</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image_with_boxes</span>
</code></pre></div></div>

<p>Where:</p>
<ul>
  <li>mean_box is the weighted average position of the particles.</li>
  <li>Draw bounding boxes for both the weighted average position and the particle with the maximum weight.</li>
</ul>

<h3 id="7draw-particles">7.Draw Particles</h3>
<p>Visualize particles on the image. The size of each particle is proportional to its weight.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_particles</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="n">image_with_particles</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">states</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="mi">2</span><span class="p">]).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">cv2</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">image_with_particles</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="nf">int</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="n">w</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">thickness</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">image_with_particles</span>
</code></pre></div></div>

<p>Use cv2.circle to draw each particle, with the size proportional to the particle’s weight.</p>

<h3 id="8-main-loop">8. Main Loop</h3>
<p>Process each video frame iteratively, performing prediction, update, resampling, and visualization.</p>

<h3 id="create-video-reader-object">Create Video Reader Object</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cap</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nc">VideoCapture</span><span class="p">(</span><span class="sh">'</span><span class="s">DSCF2822.MP4</span><span class="sh">'</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">cap</span><span class="p">.</span><span class="nf">isOpened</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Error: Could not open video file.</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Explanation: cv2.VideoCapture creates an object to read from the video file DSCF2822.MP4.</li>
  <li>Check: The if not cap.isOpened() block verifies that the video file was successfully opened. If not, it prints an error message and exits the program.</li>
</ul>

<h4 id="read-the-first-frame">Read the First Frame</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ret</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Error: Could not read the first frame.</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Explanation: cap.read() reads the first frame from the video.</li>
  <li>Check: If reading the first frame fails (ret is False), it prints an error message and exits.</li>
</ul>

<h3 id="initialization-of-number-of-particles-and-initial-state">Initialization of Number of Particles and Initial State</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_of_particles</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">s_init</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1600</span><span class="p">,</span> <span class="mi">700</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># initial state [x_center, y_center, x_velocity, y_velocity]
</span></code></pre></div></div>

<ul>
  <li>set the number of particles used in the particle filter to 500. More particles generally provide better tracking accuracy but require more computation.</li>
  <li>s_init represents the initial state of the object being tracked. It is an array with four elements:x and y position and velocity.</li>
</ul>

<p>Bounding Box Dimensions: 
These values define the dimensions of the bounding box around the object being tracked.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">half_height</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">half_width</span> <span class="o">=</span> <span class="mi">80</span>
</code></pre></div></div>

<p>Video Parameters</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">frame_width</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">frame_height</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">fps</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># cap.get(5)  # frames per second
</span></code></pre></div></div>

<ul>
  <li>frame_width and frame_height get the dimensions of the video frames from the cap object.</li>
  <li>fps sets the frames per second for the output video. Although commented out, it would typically be retrieved from the video file.</li>
</ul>

<h3 id="initialize-the-video-writer">Initialize the Video Writer</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_width</span><span class="p">,</span> <span class="n">frame_height</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nc">VideoWriter</span><span class="p">(</span><span class="sh">'</span><span class="s">nini_tracked.avi</span><span class="sh">'</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="nc">VideoWriter_fourcc</span><span class="p">(</span><span class="o">*</span><span class="sh">'</span><span class="s">MJPG</span><span class="sh">'</span><span class="p">),</span> <span class="n">fps</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">.</span><span class="nf">isOpened</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Error: Could not open video writer.</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="get-the-normalized-histogram-of-the-initial-state">Get the Normalized Histogram of the Initial State</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q</span> <span class="o">=</span> <span class="nf">compute_norm_hist</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">s_init</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Explanation:</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">compute_norm_hist</code> computes the histogram for the initial state s_init of the object in the first frame.</p>

<p>This histogram serves as the reference for comparing with histograms of particles in subsequent frames.</p>

<h3 id="initialize-particles-and-weights">Initialize Particles and Weights</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s_new</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">tile</span><span class="p">(</span><span class="n">s_init</span><span class="p">,</span> <span class="p">(</span><span class="n">num_of_particles</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">T</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">num_of_particles</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>s_new initializes the state of all particles to the initial state s_init. np.tile creates a matrix where each column is s_init, and .T transposes it to match the required shape.</li>
  <li>weights initializes the weight of each particle to 1, assuming equal probability for all particles initially.</li>
</ul>

<h2 id="main-loop">Main Loop</h2>
<p>Processing frames:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># go over the frames in the video
</span><span class="n">frame_count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="c1"># sample new particles according to the weights
</span>    <span class="n">s_sampled</span> <span class="o">=</span> <span class="nf">sample_particle</span><span class="p">(</span><span class="n">s_new</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="c1"># predict new particles (states) according to the previous states
</span>    <span class="n">s_new</span> <span class="o">=</span> <span class="nf">predict_particles</span><span class="p">(</span><span class="n">s_sampled</span><span class="p">)</span>
    <span class="c1"># go over the new predicted states, and compute the histogram for the state and
</span>    <span class="c1"># the weight with the original histogram
</span>    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">s_new</span><span class="p">.</span><span class="n">T</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nf">compute_norm_hist</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="nf">compute_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

    <span class="c1"># draw bounding box over the tracked object
</span>    <span class="n">image_with_boxes</span> <span class="o">=</span> <span class="nf">draw_bounding_box</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">s_new</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">with_max</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">result</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">image_with_boxes</span><span class="p">)</span>

    <span class="c1"># read next frame
</span>    <span class="n">ret</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="nf">read</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>  <span class="c1"># if there is no next frame to read, stop
</span>        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">End of video at frame </span><span class="si">{</span><span class="n">frame_count</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="n">frame_count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">frame_count</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Processed frame </span><span class="si">{</span><span class="n">frame_count</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># release video objects
</span><span class="n">cap</span><span class="p">.</span><span class="nf">release</span><span class="p">()</span>
<span class="n">result</span><span class="p">.</span><span class="nf">release</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Video processing completed and file saved.</span><span class="sh">"</span><span class="p">)</span>

</code></pre></div></div>]]></content><author><name>true</name></author><category term="Particle" /><category term="Filter" /><category term="Implemented" /><category term="in" /><category term="Python" /><category term="Tutorial" /><summary type="html"><![CDATA[Particle Filters implemented in Object tracking What’s Paricle filters?]]></summary></entry><entry><title type="html">Kalman Filter Implemented in Python</title><link href="http://localhost:4000/2024/07/18/Kalman-filter-in-Python-copy.html" rel="alternate" type="text/html" title="Kalman Filter Implemented in Python" /><published>2024-07-18T01:00:00+01:00</published><updated>2024-07-18T01:00:00+01:00</updated><id>http://localhost:4000/2024/07/18/Kalman%20filter%20in%20Python%20copy</id><content type="html" xml:base="http://localhost:4000/2024/07/18/Kalman-filter-in-Python-copy.html"><![CDATA[<h1 id="kalman-filter">Kalman Filter</h1>

<p>In many real-world applications, such as tracking the position of a moving vehicle, we rely on models to predict the state of a system. However, these predictions are never perfect due to uncertainties and noise in the system. To improve the accuracy of our state estimates, we use a method called the Kalman filtering.</p>

<p>The Kalman filter is an efficient recursive algorithm that estimates the state of a dynamic system from a series of incomplete and noisy measurements.</p>

<p><strong>Modeling a Dynamic System</strong></p>

<p>The dynamics of the system can be represented by the following equations:</p>
<ul>
  <li>The model of the system without noise is:</li>
</ul>

\[\dot{\mathbf x} = \mathbf{Ax}\]

<ul>
  <li>The model of the system with noise is:</li>
</ul>

\[\dot{\mathbf x} = \mathbf{Ax} + \mathbf w\]

<p>Consider any inputs into the system. We assume an input $\mathbf u$, and a linear model matrix $\mathbf B$ is set to convert $\mathbf u$ into the effect on the system.</p>

<ul>
  <li>Including Inputs:</li>
</ul>

\[\dot{\mathbf x} = \mathbf{Ax} + \mathbf{Bu} + \mathbf{w}\]

<p>Where：</p>

<ul>
  <li>
    <p>$\dot{\mathbf x}$ is time derivative of the state $\mathbf x$
, representing the rate of change of the system’s state.</p>
  </li>
  <li>
    <p>$\mathbf{A}$ is the system matrix, which describes the relationship between the state variables.</p>
  </li>
  <li>
    <p>$\mathbf{B}$  is the input matrix, which describes how the input vector $\mathbf{u}$  affects the state variables.</p>
  </li>
  <li>
    <p>$\mathbf{u}$  is the input vector, containing the control inputs to the system.</p>
  </li>
  <li>
    <p>$\mathbf{w}$  is the disturbance vector, representing external disturbances or noise affecting the system.</p>
  </li>
</ul>

<p>These equations form the foundation for modeling dynamic systems, allowing engineers to predict and analyze the system’s behavior under varying conditions and inputs.</p>

<p><strong>State Transition Equation</strong></p>

<p>While continuous-time dynamic models provide theoretical insights into how system states change over time, practical applications demand more specific and actionable models to predict and manage system behaviors at specific moments. This is where the introduction of the state transition equation becomes crucial.</p>

<p>The state transition equation describes how the state of a system evolves over discrete time steps:</p>

\[\mathbf x_k = \mathbf{Fx}_{k-1} + \mathbf B_k\mathbf u_k\]

<p>Where:</p>

<ul>
  <li>
    <p>${\mathbf F}$ is the state transition matrix, which has the ability to transition the state’s value between discrete time steps.</p>
  </li>
  <li>
    <p>$\mathbf{B_k}$ is the control input matrix, which specifies how the control input influences the state transition at time k. It allows flexibility in influence of external inputs in the system.</p>
  </li>
  <li>
    <p>$\mathbf{u_k}$ is the control input vector at time k. It represents external inputs or commands applied to the system at time, which affect the evolution of the state from k-1 to k.</p>
  </li>
</ul>

<p>This equation provides a framework for modeling the temporal evolution of a dynamic system under the influence of external inputs or controls. By adjusting 
F and B, engineers can simulate and analyze how different inputs affect the system’s behavior over time.</p>

<h2 id="python-implementation-of-kalman-filter">Python Implementation of Kalman Filter</h2>

<p>In this case, we use an simple 1D position and velocity example without external control inputs, which system’s state is determined solely by its own dynamics and process noise:</p>

\[\mathbf x_k = \mathbf{Fx}_{k-1}\]

<h4 id="step-1-given-offsers-of-each-variables-in-the-state-vector">Step 1 Given offsers of each variables in the state vector</h4>

<p>These defines the order of the state variables in our vector $\mathbf x$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="c1"># offsets of each variable in the state vector
</span><span class="n">iX</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">iV</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">NUMVARS</span> <span class="o">=</span> <span class="n">iV</span> <span class="o">+</span> <span class="mi">1</span>  
</code></pre></div></div>

<ul>
  <li>‘iX’ and ‘iV’ are the indices for position and velocity in the state vector, respectively.
    <ul>
      <li>in this case, we have 
  \(\mathbf x = \begin{bmatrix}x&amp;v\end{bmatrix}^T\), where $x$ is position, and $v$ is the velocity</li>
    </ul>
  </li>
  <li>‘NUMVARS’ represents the number of variables in the state vector, which is 2 in this case (position and velocity)
    <ul>
      <li>this will be used to initialise the size of our arrays.</li>
    </ul>
  </li>
</ul>

<h4 id="step-2-initialize-the-class-object-instance">Step 2 Initialize the class object instance:</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">KF</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">initial_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">initial_v</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">accel_variance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># mean of state GRV
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">NUMVARS</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_x</span><span class="p">[</span><span class="n">iX</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_x</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">_x</span><span class="p">[</span><span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_v</span>  
        <span class="n">self</span><span class="p">.</span><span class="n">_accel_variance</span> <span class="o">=</span> <span class="n">accel_variance</span>
        <span class="c1"># covariance of state GRV
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="n">NUMVARS</span><span class="p">)</span>

</code></pre></div></div>

<p>init initializes the Kalman filter instance variables:</p>
<ul>
  <li>self._x is the state vector $\mathbf x$, including position and velocity, initialized to a zero vector and then set to the initial position and velocity.</li>
  <li>self._accel_variance is the variance of the acceleration, describing the process noise in the system.</li>
  <li>self._P is the state covariance matrix, initialized to an identity matrix, representing the initial covariance between position and velocity.</li>
</ul>

<h4 id="step-3-prediction-state-prediction-and-covariance-prediction">Step 3 Prediction: state prediction and covariance prediction</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="n">NUMVARS</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="n">iX</span><span class="p">,</span> <span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span> 
    <span class="n">new_x</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_x</span><span class="p">)</span> 
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">G</span><span class="p">[</span><span class="n">iX</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">G</span><span class="p">[</span><span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span> 
    <span class="n">new_P</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_P</span><span class="p">).</span><span class="nf">dot</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">G</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">_accel_variance</span>

    <span class="n">self</span><span class="p">.</span><span class="n">_P</span> <span class="o">=</span> <span class="n">new_P</span>
    <span class="n">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">new_x</span>
</code></pre></div></div>

<p><strong>1. State prediction</strong></p>

<p>F is the state transition matrix, we have position and velocity to track, and to describe how the state evolves over a time step dt, $F$ is:</p>

\[\begin{aligned}
\mathbf F &amp;= \begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix} + \begin{bmatrix}0&amp;1\\0&amp;0\end{bmatrix}\Delta t\\
&amp;= \begin{bmatrix}1&amp;\Delta t\\0&amp;1\end{bmatrix}
\end{aligned}\]

<p>Apply this into $\mathbf x_k= \mathbf{Fx}_{k-1}$ to get the predict new_x, which is:</p>

\[\begin{aligned}
\mathbf x_k &amp;=\begin{bmatrix}1&amp;\Delta t\\0&amp;1\end{bmatrix} \mathbf x_{k-1}
\end{aligned}\]

<p><strong>2. Covariance prediction:</strong>
In addition to predicting the state, it’s essential to predict the covariance because the covariance matrix describes the uncertainty of the state estimation. We denote the predicted covariance matrix as $P_{k+1}$. There are two components in this part:</p>

<ol>
  <li>
    <p><strong>Impact of State Prediction on Covariance:</strong></p>

    <p>During the state prediction (predict) phase, the current state covariance matrix is updated to the predicted state covariance matrix using the state transition matrix F and the process noise covariance matrix 𝑄. This step accounts for the uncertainty in state changes that the system model cannot fully capture.</p>
  </li>
  <li>
    <p><strong>Contribution of Process Noise:</strong></p>

    <p>The process noise covariance matrix Q plays a crucial role in the state prediction by describing the unmodeled dynamic changes in the system and the influence of control inputs. It directly affects the size and structure of the predicted state covariance matrix.</p>
  </li>
</ol>

<p>Based on these two factors, we predict the new state covariance matrix ( P ):</p>

\[\mathbf{P}_{k+1} = F \mathbf{P}_k F^T + Q\]

<p>Recall that Q describes the unmodeled dynamic changes in the system and the influence of control inputs, so it involves G and $\sigma_a^2$:</p>

\[\mathbf{Q} = G G^T \sigma^2_a\]

<p>To sum up:</p>

\[\mathbf{P}_{k+1} = F \mathbf{P}_k F^T + G G^T \sigma^2_a\]

<p>where  $\sigma^2_a $ is the variance of the acceleration noise.</p>

<p><strong>G</strong>
This prediction involves two main components:
For an object moving with constant acceleration a, the position change over a time interval dt can be expressed as:
\(x = x_0 + v_0 \cdot dt + \frac{1}{2} a \cdot dt^2\)</p>

<p>So that, <code class="language-plaintext highlighter-rouge">G[iX] = 0.5 * dt^2</code> and <code class="language-plaintext highlighter-rouge">G[iV] = dt</code> indicate the influence of acceleration noise on position and velocity over the time step $t$ and $G$ matrix is:
The process noise influence matrix ( $G$ ) is:</p>

\[G = \begin{pmatrix} 
0.5 \cdot dt^2 \\ 
dt 
\end{pmatrix}\]

<ul>
  <li>Process Noise Influence Matrix $G$:</li>
  <li>$G$ is the matrix describing the influence of process noise on the system state. Its size matches the state vector.</li>
  <li>The $G$ matrix considers the impact of acceleration noise on both position and velocity.</li>
  <li><code class="language-plaintext highlighter-rouge">G[iX] = 0.5 * dt^2</code> and <code class="language-plaintext highlighter-rouge">G[iV] = dt</code> indicate the influence of acceleration noise on position and velocity over the time step t.</li>
</ul>

<p>Using the G matrix, we predict the new state covariance matrix ( P ):</p>

\[\mathbf{P}_{k+1} = F \mathbf{P}_k F^T + G G^T \sigma^2_a\]

<p>where  $\sigma^2_a $ is the variance of the acceleration noise.</p>

<h4 id="step-4-update">Step 4 Update</h4>

<p>The update step is crucial because it allows the Kalman filter to correct its predictions based on new measurements. Imagine you have a system (like a moving car) and you’re trying to estimate its position and speed. You use a model to predict where the car will be, but your prediction won’t be perfect due to uncertainties (like changes in speed or direction).</p>

<p>Every time you get a new measurement (like a GPS reading), you can use this new information to correct your estimate. This makes your estimation more accurate than just relying on predictions alone.</p>

<p>The update step of the Kalman filter utilizes linear algebra and probability theory to dynamically adjust the state estimate based on real-time measurement data. These mathematical formulas ensure that the filter optimally balances between the system dynamics and measurement uncertainties, providing accurate and reliable state estimation.</p>

<p>Thus, the update step involves correcting the predicted state estimate based on the new measurement. Here’s a detailed explanation of the update process:</p>

<ol>
  <li>
    <p><strong>Calculate Measurement Residual:</strong></p>

    <p>Calculate the measurement residual $y$ , which is the difference between the actual measurement $z$  and the predicted measurement based on the current state estimate</p>

\[y = z - H \mathbf{x}\]

    <p>where:</p>
    <ul>
      <li>$\mathbf{z}$ is the measured measurement.</li>
      <li>$\mathbf{H}$ is the observation matrix that maps the state vector into the measurement space.</li>
      <li>$\mathbf{x}$  is the predicted state vector.</li>
    </ul>
  </li>
  <li>
    <p><strong>Calculate Residual Covariance:</strong></p>

    <p>Compute the residual covariance $S$ , which combines the prediction uncertainty and measurement noise:</p>
  </li>
</ol>

\[S = H \mathbf{P} H^T + R\]

<p>where:</p>
<ul>
  <li>$\mathbf{P}$   is the predicted state covariance matrix.</li>
  <li>$\mathbf{R}$   is the covariance matrix of the measurement noise.</li>
</ul>

<ol>
  <li>
    <p><strong>Compute Kalman Gain:</strong></p>

    <p>The Kalman Gain is a factor that determines how much you should adjust your prediction based on the new measurement. It balances the uncertainty in your prediction against the uncertainty in the measurement. If your prediction is very uncertain but your measurement is very accurate, the Kalman Gain will be higher, meaning you trust the measurement more.
Calculate the Kalman gain $ K $, which determines how much the predicted state estimate is adjusted based on the measurement residual:</p>

\[K = \mathbf{P} H^T (H \mathbf{P} H^T + R)^{-1}\]
  </li>
  <li>
    <p><strong>Update State Estimate:</strong></p>

    <p>Update the state estimate  $\mathbf{x}$  using the Kalman gain and the measurement residual:</p>

\[\mathbf{x}^+ = \mathbf{x} + K y\]

    <p>Adjust your previous state estimate by adding the product of the Kalman Gain and the residual. This step corrects the prediction by bringing it closer to the actual measurement.</p>
  </li>
  <li>
    <p><strong>Update Covariance Matrix:</strong></p>

    <p>Update the covariance matrix $ \mathbf{P} $ to reflect the incorporation of new measurement information:</p>

\[\mathbf{P}^+ = (I - K H) \mathbf{P}\]
  </li>
</ol>

<h3 id="significance-in-applications">Significance in Applications</h3>

<p>The update step enables the Kalman filter to adaptively adjust the state estimate according to real-world measurement data, facilitating precise tracking and prediction of system states. This capability makes the Kalman filter invaluable in real-time applications such as navigation systems, robotics, and sensor data processing.</p>

<p><strong>Implementation of Update in Python:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">meas_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">meas_variance</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="c1"># y = z - H x
</span>        <span class="c1"># S = H P Ht + R
</span>        <span class="c1"># K = P Ht S^-1
</span>        <span class="c1"># x = x + K y
</span>        <span class="c1"># P = (I - K H) * P
</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]).</span><span class="nf">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">meas_value</span><span class="p">])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">meas_variance</span><span class="p">])</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">H</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_x</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">H</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_P</span><span class="p">).</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_P</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">T</span><span class="p">).</span><span class="nf">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">inv</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
        
        <span class="n">new_X</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">+</span> <span class="n">K</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">new_P</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">K</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">)).</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_P</span><span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="n">_P</span> <span class="o">=</span> <span class="n">new_P</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">new_X</span>
</code></pre></div></div>

<h2 id="using-the-kf">Using the KF</h2>
<p>Now let’s test the kalman filter implementation</p>

<p>We now create the <code class="language-plaintext highlighter-rouge">main.py</code> script to demonstrates how to use the Kalman Filter to track the position and velocity of an object over time.To better observe the performance of the Kalman Filter, we need to set up the plotting environment and initialize various parameters:</p>

<p><strong>1. Import Libraries and Modules and Set Plotting Environment:</strong></p>

<p>Import the necessary libraries and modules. numpy is used for numerical computations, matplotlib for plotting, and KF is the Kalman Filter implementation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="n">kf</span> <span class="kn">import</span> <span class="n">KF</span> 
</code></pre></div></div>

<p><strong>2. Initialization and Parameter Setup</strong></p>

<p>Initializing the real position and velocity of the object is necessary to simulate the actual state of the system we want to track. This provides a reference to compare against the filter’s estimates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">real_x</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">meas_variance</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">real_v</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">kf</span> <span class="o">=</span> <span class="nc">KF</span><span class="p">(</span><span class="n">initial_x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">initial_v</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">accel_variance</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>3. Simulation Parameters</strong></p>

<p>Defining the noise in the measurements simulates real-world sensor inaccuracies. This helps in testing the filter’s ability to handle and correct noisy data.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DT</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">NUM_STEPS</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">MEAS_EVERY_STEPS</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">mus</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">real_xs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">real_vs</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DT</code> is the time step, controlling the interval at which the simulation updates.</li>
  <li><code class="language-plaintext highlighter-rouge">NUM_STEPS</code> is the total number of steps to simulate, determining the duration of the simulation.</li>
  <li><code class="language-plaintext highlighter-rouge">MEAS_EVERY_STEPS</code> defines how often we take measurements, simulating periodic sensor readings.</li>
  <li><code class="language-plaintext highlighter-rouge">mus</code>, <code class="language-plaintext highlighter-rouge">covs</code>, <code class="language-plaintext highlighter-rouge">real_xs</code>, and <code class="language-plaintext highlighter-rouge">real_vs</code> are lists to store the filter’s estimates, covariances, and the true positions and velocities for later analysis and plotting.</li>
</ul>

<p><strong>4. Simulation Loop</strong></p>

<p>To emulate the dynamic behavior of the system over time and to observe how the Kalman Filter performs in real-time tracking of the object’s state, we use simulation loop.  Here’s a detailed explanation of why we need the simulation loop:</p>
<ul>
  <li><strong>Dynamic Behavior Simulation:</strong> 
  In real-world applications, the state of the system (such as the position and velocity of an object) changes continuously over time. The simulation loop allows us to replicate this dynamic behavior in a controlled environment, updating the state of the system at each time step.</li>
  <li><strong>State Prediction and Update:</strong>
  The Kalman Filter operates in two main steps: prediction and update. The simulation loop enables these steps to be executed repeatedly.</li>
  <li><strong>Performance Evaluation:</strong>
  By running the simulation loop over multiple iterations, we can observe how well the Kalman Filter tracks the system’s state over time. This helps in evaluating the filter’s accuracy and responsiveness to changes in the system.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">NUM_STEPS</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
        <span class="n">real_v</span> <span class="o">*=</span> <span class="mf">0.9</span>

    <span class="n">covs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">kf</span><span class="p">.</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">mus</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">kf</span><span class="p">.</span><span class="n">mean</span><span class="p">)</span>
    
    <span class="n">real_x</span> <span class="o">=</span> <span class="n">real_x</span> <span class="o">+</span> <span class="n">DT</span> <span class="o">*</span> <span class="n">real_v</span>

    <span class="n">kf</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span><span class="n">dt</span> <span class="o">=</span> <span class="n">DT</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">%</span> <span class="n">MEAS_EVERY_STEPS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kf</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">meas_value</span> <span class="o">=</span> <span class="n">real_x</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">meas_variance</span><span class="p">),</span> 
                  <span class="n">meas_variance</span> <span class="o">=</span> <span class="n">meas_variance</span><span class="p">)</span>

    <span class="n">real_xs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">real_x</span><span class="p">)</span>
    <span class="n">real_vs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">real_v</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>5. Plotting</strong></p>

<p>To visually assess the Kalman Filter’s performance in estimating dynamic system states from noisy measurements, plotting is indispensable. It provides a clear comparison between estimated and actual states, visualizes uncertainties, aids in performance evaluation, and facilitates debugging and optimization of the filter implementation.</p>

<p>Apart from the estimated and actual states, we also plot the Confidence Interval of the estimated position/velocity (mean ± 2 standard deviations), which helps us understand the range within which the true velocity is likely to lie with a high degree of confidence. It reflects the uncertainty in our velocity estimation due to measurement variations and model assumptions. Plotting this interval alongside the estimated velocity (mu[1]) allows us to visualize the accuracy and reliability of our velocity predictions throughout the simulation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Position</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">mus</span><span class="p">],</span> <span class="sh">'</span><span class="s">g</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">real_xs</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">covs</span><span class="p">)],</span> <span class="sh">'</span><span class="s">r--</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">covs</span><span class="p">)],</span> <span class="sh">'</span><span class="s">r--</span><span class="sh">'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Velocity</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">mus</span><span class="p">],</span> <span class="sh">'</span><span class="s">g</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">real_vs</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">covs</span><span class="p">)],</span> <span class="sh">'</span><span class="s">r--</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">covs</span><span class="p">)],</span> <span class="sh">'</span><span class="s">r--</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="\assets\2024-07-18-KalmanFilter\kalman_filter.png" alt="Description of the image" width="500" height="320" /></p>

<ul>
  <li>
    <p><strong>The first subplot (top) titled ‘Position’ displays：</strong></p>

    <ol>
      <li>Green solid line: Estimated position <code class="language-plaintext highlighter-rouge">mu[0]</code> from the Kalman filter.</li>
      <li>Blue solid line: Real position <code class="language-plaintext highlighter-rouge">real_xs</code>.</li>
      <li>Red dashed lines: Confidence interval of the estimated position <code class="language-plaintext highlighter-rouge">mean ± 2 standard deviations</code>.</li>
    </ol>
  </li>
  <li>
    <p><strong>The second subplot (bottom) titled ‘Velocity’ displays:</strong></p>
    <ol>
      <li>Green solid line: Estimated position <code class="language-plaintext highlighter-rouge">mu[0]</code> from the Kalman filter.</li>
      <li>Blue solid line: Real velocity <code class="language-plaintext highlighter-rouge">real_vs</code>.</li>
      <li>Red dashed lines: Confidence interval of the estimated velocity <code class="language-plaintext highlighter-rouge">mean ± 2 standard deviations</code>.</li>
    </ol>
  </li>
</ul>

<p><strong>Performance Evaluation:</strong></p>

<ul>
  <li>
    <p><strong>Position:</strong></p>

    <p>The predicted positions closely match the true values, indicating excellent performance of the Kalman filter in tracking the system’s position. Additionally, the confidence interval for the estimated velocity is narrow, suggesting high confidence in the velocity estimates and minimal deviation from the actual velocity values. However, there may be noticeable fluctuations near zero, possibly due to inaccuracies in the system model when the position is near stationary or at rest.</p>
  </li>
  <li>
    <p><strong>Velocity:</strong></p>

    <p>Regarding velocity, the predicted values closely approximate the true values overall. However, during changes in velocity, there are noticeable discrepancies. The confidence interval is broader compared to position, indicating lower confidence in velocity estimates and larger potential deviations from actual values. Similar to position, there are significant fluctuations around zero, which are more pronounced for velocity estimates than for position estimates.</p>
  </li>
</ul>

<p><strong>Conclusion</strong></p>

<p>The Kalman filter demonstrates strong performance in tracking the position of the object, with predictions closely matching the true values. The confidence interval for position estimation remains narrow, indicating high confidence in these predictions, except for fluctuations near zero where variability increases.    For velocity, while the Kalman filter accurately tracks changes, there are some deviations observed during rapid changes. The confidence interval for velocity estimates is high, suggesting lower uncertainty in velocity predictions. Same to the position prediction, around zero the fluctuations are more pronounced.  Overall, the Kalman filter effectively reduces noise and provides reliable state estimation for dynamic systems.</p>]]></content><author><name>true</name></author><category term="KalmanFilter" /><category term="StateEstimation" /><category term="Tutorial" /><summary type="html"><![CDATA[Kalman Filter]]></summary></entry><entry><title type="html">Computer Science fundamental</title><link href="http://localhost:4000/2024/07/18/Computer_Science.html" rel="alternate" type="text/html" title="Computer Science fundamental" /><published>2024-07-18T01:00:00+01:00</published><updated>2024-07-18T01:00:00+01:00</updated><id>http://localhost:4000/2024/07/18/Computer_Science</id><content type="html" xml:base="http://localhost:4000/2024/07/18/Computer_Science.html"><![CDATA[<p>Owner: Xiaofan SHEN
Tags: Infrastructure</p>

<h1 id="python">Python</h1>

<h3 id="variables"><strong>Variables</strong></h3>

<p>A <strong>variable</strong> in a program acts like a container. It can be used to store a string, a number, or other kinds of data.</p>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/box-and-tangible-value-4-mol6CH.png" alt="box-and-tangible-value-4-mol6CH.png" /></p>

<p><strong>str1.find(str2)</strong></p>

<aside>
💡 **str1.find(str2)**

</aside>

<h1 id="parallelism">Parallelism</h1>

<ul>
  <li>When multiple workers can split up a problem without adding in coordination overhead, computer scientists sometimes call the problem <strong>embarrassingly parallel</strong>.</li>
  <li></li>
</ul>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/Untitled.png" alt="Untitled" /></p>

<h2 id="pipelining">Pipelining</h2>

<p><strong>Pipelining</strong> is a form of parallelism where tasks are solved faster by having multiple tasks simultaneously at various levels of completion.</p>

<p>Parallelism can improve performance by improving <strong>latency</strong> (the time that a task takes from beginning to end) or by improving <strong>throughput</strong> (the amount of tasks that can complete during a given interval of time).</p>

<h1 id="resource-tradeoffs"><strong>Resource Tradeoffs</strong></h1>

<p>Inexpensive computers can perform 3 basic computations in a nanosecond — that’s one (wildly oversimplified) way of describing what it means to be a “3 GHz” computer.</p>

<h2 id="caching">Caching</h2>

<p><strong>Caching</strong> is a general problem-solving approach that provides a much more flexible way of dealing with certain resource tradeoffs.</p>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/computer-processor-diagram-ULTlpu.png" alt="**Hardware caches**" /></p>

<p><strong>Hardware caches</strong></p>

<h2 id="api">API</h2>

<p>An API is an interface or menu that different programs can use to communicate with each other.</p>

<aside>
💡 An **interface** is an abstraction that manages complexity by defining how to **interact** with a process while hiding how the process **actually** gets donLisLis

</aside>

<p><em>“向荆市长隐藏的信息允许档案部在不打扰荆市长的情况下改变其工作方式。这是界面意义的重要组成部分。”</em></p>

<h2 id="binary-search">Binary Search</h2>

<p><strong>Bridges of Königsberg</strong></p>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/konigsberg-bridge_-simplified-w-nsew-2-xpQnkF.png" alt="konigsberg-bridge_-simplified-w-nsew-2-xpQnkF.png" /></p>

<p>图中每条边都经过一次的路径称为<strong>欧拉路径</strong>。</p>

<aside>
💡 一条路径只有一个端点和一个起点，因此如果一个图有两个以上的顶点，且连接边的数量为奇数，那么就不可能存在欧拉路径。

</aside>

<aside>
💡 移除柯尼斯堡的**任何一座**桥都只留下两个具有奇数条连接边的顶点。这意味着移除**任何**一座桥都可以形成欧拉路径。

</aside>

<h2 id="breadth-first-search--depth-first-search"><strong>Breadth-first search  Depth-first search</strong></h2>

<p>A <strong>list</strong> is a data type for storing multiple items of the same type that are related and belong together.</p>

<h2 id="list">List</h2>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/diff-variable-names-okay-2TIHqg.png" alt="diff-variable-names-okay-2TIHqg.png" /></p>

<h2 id="pseudocode"><strong>pseudocode</strong></h2>

<p>Writing the logic of programs in English is called <strong>pseudocode</strong>.</p>

<p>An <strong>algorithm</strong> is a step by step process designed to achieve some outcome, and computers are the fastest machines ever conceived for carrying out step by step processes!</p>

<p>That means that the study of algorithms is a core aim of computer science, but their use transcends any one discipline.</p>

<p>Code worked or delivered</p>

<p>When a computer scientist says an algorithm “works,” that doesn’t just mean it promises to produce a correct result. It also has to deliver on that promise, <em>finish</em>, and produce the result, on every possible input.</p>

<p>Making sure an algorithm always finishes and produces a result is called <em>proving termination</em>, and it can be a little bit tricky!</p>

<p>Langton’s ant、Boolean</p>

<h2 id="aconditional-statementuses-a-boolean-expression-to-determine-the-code-that-is-run">A <strong>conditional statement</strong> uses a Boolean expression to determine the code that is run.</h2>

<p>Dictionary</p>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/Untitled%201.png" alt="Untitled" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cleaned_word = word.lower().strip(punctuation)
</code></pre></div></div>

<p>reader = open(‘data/jekyll.txt’)
punctuation = ‘.;,-“’”:?—‘!()_’</p>

<p>freq_dict = {}
for line in reader:
for word in line.split():
cleaned_word = word.lower().strip(punctuation)
if cleaned_word in freq_dict:
freq_dict[cleaned_word]+=1
else:
freq_dict[cleaned_word]=1</p>

<p>print(len(freq_dict))</p>

<h2 id="counter"><strong>Counter</strong></h2>]]></content><author><name>true</name></author><category term="Computer" /><category term="Science" /><category term="fundamental" /><summary type="html"><![CDATA[Owner: Xiaofan SHEN Tags: Infrastructure]]></summary></entry><entry><title type="html">Table-scale Dynamic Haptic feedback for virtual reality utilized an object-moving robot</title><link href="http://localhost:4000/2022/09/27/MSc_Project.html" rel="alternate" type="text/html" title="Table-scale Dynamic Haptic feedback for virtual reality utilized an object-moving robot" /><published>2022-09-27T01:00:00+01:00</published><updated>2022-09-27T01:00:00+01:00</updated><id>http://localhost:4000/2022/09/27/MSc_Project</id><content type="html" xml:base="http://localhost:4000/2022/09/27/MSc_Project.html"><![CDATA[<h3 id="introduction">Introduction</h3>
<p>This project introduces a system that provides a dynamic table-scale haptic feedback for virtual reality, by using a robot that can move one mug on the table to map three virtual mugs in virtual reality. 
<img src="/assets/2022-09-27-MSc_Project/structure.png" alt="Description of the image" width="400" height="220" /></p>

<h4 id="hardware">Hardware</h4>
<p>An accurate tracking system is essential for tracking objects in this project. A headset mounted display (HMD), two controllers, two lighthouse BASE stations, and two VIVE
trackers 2.0 made up the setup of the Vive System.
 <img src="/assets/2022-09-27-MSc_Project/trackingarea.png" alt="Description of the image" width="580" height="380" />
 <br />
By synchronizing information from the real and virtual worlds and giving commands to the robot, users can touch and lift objects in virtual content with their hands carrying the controller. When the user gives a demand to touch a specific mug, the robot is activated to reconfigure the real world. 
 <img src="/assets/photos/userthink.png" alt="Description of the image" width="560" height="360" />
Similarly, virtual contents also changes along with operation conducted to the real mug (such as moving it or lifting it by the user) to achieve a sense of reality.</p>

<h4 id="experiments">Experiments</h4>
<iframe type="text/html" width="100%" height="385" src="https://youtube.com/embed/uQ05KesgF34" frameborder="0"></iframe>]]></content><author><name>true</name></author><category term="Robotics" /><category term="VR" /><category term="Haptic" /><summary type="html"><![CDATA[Introduction This project introduces a system that provides a dynamic table-scale haptic feedback for virtual reality, by using a robot that can move one mug on the table to map three virtual mugs in virtual reality.]]></summary></entry><entry><title type="html">Face morping</title><link href="http://localhost:4000/2022/04/07/Face-morping.html" rel="alternate" type="text/html" title="Face morping" /><published>2022-04-07T01:00:00+01:00</published><updated>2022-04-07T01:00:00+01:00</updated><id>http://localhost:4000/2022/04/07/Face%20morping</id><content type="html" xml:base="http://localhost:4000/2022/04/07/Face-morping.html"><![CDATA[<p>This project ‘face morphing’ is divided into 7 parts to complete a smooth transfer video from two
faces;</p>
<ol>
  <li>‘dlib’ face landmark detector is used to detect 68 landmarks on 2 images, as 68 landmarks are
not covering all the face, 20 landmarks are manually added, including 16 landmarks on the face,
while 4 points locates the background, so that the background could also transfer smoothly;</li>
  <li>the standard Delaunay Triangulation is used to visualize triangulation of vertices(landmarks);</li>
  <li>get the interpolating between image1 and image2 by applying
x int = (x img1 + ximg2)/2
y int = (y img1 + yimg2)/2</li>
  <li>Getting parameters of the affine warp when vertices of two triangle were given, and between
every pairs of corresponding triangles, Affine warp was estimated;</li>
  <li>Find the all coordinates which are inside the given triangle, and then a labeled image was created
by dividing face into parts;</li>
  <li>Get the in - between image for a given ‘w’</li>
  <li>Create the transfer video;</li>
</ol>

<iframe type="text/html" width="100%" height="385" src="https://www.youtube.com/embed/0kpqJpmSTOg" frameborder="0"></iframe>]]></content><author><name>true</name></author><category term="Robotics" /><category term="VR" /><category term="Haptic" /><summary type="html"><![CDATA[This project ‘face morphing’ is divided into 7 parts to complete a smooth transfer video from two faces; ‘dlib’ face landmark detector is used to detect 68 landmarks on 2 images, as 68 landmarks are not covering all the face, 20 landmarks are manually added, including 16 landmarks on the face, while 4 points locates the background, so that the background could also transfer smoothly; the standard Delaunay Triangulation is used to visualize triangulation of vertices(landmarks); get the interpolating between image1 and image2 by applying x int = (x img1 + ximg2)/2 y int = (y img1 + yimg2)/2 Getting parameters of the affine warp when vertices of two triangle were given, and between every pairs of corresponding triangles, Affine warp was estimated; Find the all coordinates which are inside the given triangle, and then a labeled image was created by dividing face into parts; Get the in - between image for a given ‘w’ Create the transfer video;]]></summary></entry><entry><title type="html">Immersive Virtual Reality Cooking Game</title><link href="http://localhost:4000/2022/03/01/VR-game.html" rel="alternate" type="text/html" title="Immersive Virtual Reality Cooking Game" /><published>2022-03-01T00:00:00+00:00</published><updated>2022-03-01T00:00:00+00:00</updated><id>http://localhost:4000/2022/03/01/VR%20game</id><content type="html" xml:base="http://localhost:4000/2022/03/01/VR-game.html"><![CDATA[<blockquote>
  <p>This project is an engaging VR game that created an elegant environment infused with Chinese elements in Unity. Multiple players collaborated to accomplish tasks, involving research for CC0 prefabs and/or models, environment design and building, teleportation, object scripts, menu display, ingredient handling, scoring system, upgrades, and rigorous testing.</p>
</blockquote>]]></content><author><name>Jekyll</name></author><category term="VR" /><category term="Game" /><summary type="html"><![CDATA[This project is an engaging VR game that created an elegant environment infused with Chinese elements in Unity. Multiple players collaborated to accomplish tasks, involving research for CC0 prefabs and/or models, environment design and building, teleportation, object scripts, menu display, ingredient handling, scoring system, upgrades, and rigorous testing.]]></summary></entry><entry><title type="html">A Power Optimized Method in Android Systems</title><link href="http://localhost:4000/2019/08/06/android-system.html" rel="alternate" type="text/html" title="A Power Optimized Method in Android Systems" /><published>2019-08-06T00:00:00+01:00</published><updated>2019-08-06T00:00:00+01:00</updated><id>http://localhost:4000/2019/08/06/android%20system</id><content type="html" xml:base="http://localhost:4000/2019/08/06/android-system.html"><![CDATA[<h2 id="abstract">Abstract</h2>

<p>How the Suspend/Resume mechanism of smartphone influences the power consumption is examined in the dissertation. Specifically, various unimportant and not so urgent network packets keep awakening the operating system (OS) at the time it is under suspend mode, and switch it from suspend to resume mode
continually, which results in more power consumption. Accordingly, an innovative optimization technique was suggested in this paper in order that the awakening of OS can be postponed and the lasting hour of suspend mode can be lengthened to decrease power consumption. Some experiments are also carried out, with
the result data suggesting that such technique is an effective way to reduce power consumption by greater than 7.63%. It proves that this technique is workable.</p>]]></content><author><name>Jekyll</name></author><category term="Article" /><summary type="html"><![CDATA[Abstract]]></summary></entry></feed>