<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-07-19T13:23:41+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">FAN Bot</title><subtitle>your web description</subtitle><author><name>true</name></author><entry><title type="html">Kalman Filter Implemented in Python</title><link href="http://localhost:4000/2024/07/18/Kalman-filter-in-Python.html" rel="alternate" type="text/html" title="Kalman Filter Implemented in Python" /><published>2024-07-18T01:00:00+01:00</published><updated>2024-07-18T01:00:00+01:00</updated><id>http://localhost:4000/2024/07/18/Kalman%20filter%20in%20Python</id><content type="html" xml:base="http://localhost:4000/2024/07/18/Kalman-filter-in-Python.html"><![CDATA[<h1 id="kalman-filter">Kalman Filter</h1>

<p>In many real-world applications, such as tracking the position of a moving vehicle, we rely on models to predict the state of a system. However, these predictions are never perfect due to uncertainties and noise in the system. To improve the accuracy of our state estimates, we use a method called the Kalman filtering.</p>

<p>The Kalman filter is an efficient recursive algorithm that estimates the state of a dynamic system from a series of incomplete and noisy measurements.</p>

<p><strong>Modeling a Dynamic System</strong></p>

<p>The dynamics of the system can be represented by the following equations:</p>
<ul>
  <li>The model of the system without noise is:</li>
</ul>

\[\dot{\mathbf x} = \mathbf{Ax}\]

<ul>
  <li>The model of the system with noise is:</li>
</ul>

\[\dot{\mathbf x} = \mathbf{Ax} + \mathbf w\]

<p>Consider any inputs into the system. We assume an input $\mathbf u$, and a linear model matrix $\mathbf B$ is set to convert $\mathbf u$ into the effect on the system.</p>

<ul>
  <li>Including Inputs:</li>
</ul>

\[\dot{\mathbf x} = \mathbf{Ax} + \mathbf{Bu} + \mathbf{w}\]

<p>Whereï¼š</p>

<ul>
  <li>
    <p>$\dot{\mathbf x}$ is time derivative of the state $\mathbf x$
, representing the rate of change of the systemâ€™s state.</p>
  </li>
  <li>
    <p>$\mathbf{A}$ is the system matrix, which describes the relationship between the state variables.</p>
  </li>
  <li>
    <p>$\mathbf{B}$  is the input matrix, which describes how the input vector $\mathbf{u}$  affects the state variables.</p>
  </li>
  <li>
    <p>$\mathbf{u}$  is the input vector, containing the control inputs to the system.</p>
  </li>
  <li>
    <p>$\mathbf{w}$  is the disturbance vector, representing external disturbances or noise affecting the system.</p>
  </li>
</ul>

<p>These equations form the foundation for modeling dynamic systems, allowing engineers to predict and analyze the systemâ€™s behavior under varying conditions and inputs.</p>

<p><strong>State Transition Equation</strong></p>

<p>While continuous-time dynamic models provide theoretical insights into how system states change over time, practical applications demand more specific and actionable models to predict and manage system behaviors at specific moments. This is where the introduction of the state transition equation becomes crucial.</p>

<p>The state transition equation describes how the state of a system evolves over discrete time steps:</p>

\[\mathbf x_k = \mathbf{Fx}_{k-1} + \mathbf B_k\mathbf u_k\]

<p>Where:</p>

<ul>
  <li>
    <p>${\mathbf F}$ is the state transition matrix, which has the ability to transition the stateâ€™s value between discrete time steps.</p>
  </li>
  <li>
    <p>$\mathbf{B_k}$ is the control input matrix, which specifies how the control input influences the state transition at time k. It allows flexibility in influence of external inputs in the system.</p>
  </li>
  <li>
    <p>$\mathbf{u_k}$ is the control input vector at time k. It represents external inputs or commands applied to the system at time, which affect the evolution of the state from k-1 to k.</p>
  </li>
</ul>

<p>This equation provides a framework for modeling the temporal evolution of a dynamic system under the influence of external inputs or controls. By adjusting 
F and B, engineers can simulate and analyze how different inputs affect the systemâ€™s behavior over time.</p>

<h2 id="python-implementation-of-kalman-filter">Python Implementation of Kalman Filter</h2>

<p>In this case, we use an simple 1D position and velocity example without external control inputs, which systemâ€™s state is determined solely by its own dynamics and process noise:</p>

\[\mathbf x_k = \mathbf{Fx}_{k-1}\]

<h4 id="step-1-given-offsers-of-each-variables-in-the-state-vector">Step 1 Given offsers of each variables in the state vector</h4>

<p>These defines the order of the state variables in our vector $\mathbf x$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="c1"># offsets of each variable in the state vector
</span><span class="n">iX</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">iV</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">NUMVARS</span> <span class="o">=</span> <span class="n">iV</span> <span class="o">+</span> <span class="mi">1</span>  
</code></pre></div></div>

<ul>
  <li>â€˜iXâ€™ and â€˜iVâ€™ are the indices for position and velocity in the state vector, respectively.
    <ul>
      <li>in this case, we have 
  \(\mathbf x = \begin{bmatrix}x&amp;v\end{bmatrix}^T\), where $x$ is position, and $v$ is the velocity</li>
    </ul>
  </li>
  <li>â€˜NUMVARSâ€™ represents the number of variables in the state vector, which is 2 in this case (position and velocity)
    <ul>
      <li>this will be used to initialise the size of our arrays.</li>
    </ul>
  </li>
</ul>

<h4 id="step-2-initialize-the-class-object-instance">Step 2 Initialize the class object instance:</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">KF</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">initial_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">initial_v</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">accel_variance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># mean of state GRV
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">NUMVARS</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_x</span><span class="p">[</span><span class="n">iX</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_x</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">_x</span><span class="p">[</span><span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_v</span>  
        <span class="n">self</span><span class="p">.</span><span class="n">_accel_variance</span> <span class="o">=</span> <span class="n">accel_variance</span>
        <span class="c1"># covariance of state GRV
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="n">NUMVARS</span><span class="p">)</span>

</code></pre></div></div>

<p>init initializes the Kalman filter instance variables:</p>
<ul>
  <li>self._x is the state vector $\mathbf x$, including position and velocity, initialized to a zero vector and then set to the initial position and velocity.</li>
  <li>self._accel_variance is the variance of the acceleration, describing the process noise in the system.</li>
  <li>self._P is the state covariance matrix, initialized to an identity matrix, representing the initial covariance between position and velocity.</li>
</ul>

<h4 id="step-3-prediction-state-prediction-and-covariance-prediction">Step 3 Prediction: state prediction and covariance prediction</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="n">NUMVARS</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="n">iX</span><span class="p">,</span> <span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span> 
    <span class="n">new_x</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_x</span><span class="p">)</span> 
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">G</span><span class="p">[</span><span class="n">iX</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">G</span><span class="p">[</span><span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span> 
    <span class="n">new_P</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_P</span><span class="p">).</span><span class="nf">dot</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">G</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">_accel_variance</span>

    <span class="n">self</span><span class="p">.</span><span class="n">_P</span> <span class="o">=</span> <span class="n">new_P</span>
    <span class="n">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">new_x</span>
</code></pre></div></div>

<p><strong>1. State prediction</strong></p>

<p>F is the state transition matrix, we have position and velocity to track, and to describe how the state evolves over a time step dt, $F$ is:</p>

\[\begin{aligned}
\mathbf F &amp;= \begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix} + \begin{bmatrix}0&amp;1\\0&amp;0\end{bmatrix}\Delta t\\
&amp;= \begin{bmatrix}1&amp;\Delta t\\0&amp;1\end{bmatrix}
\end{aligned}\]

<p>Apply this into $\mathbf x_k= \mathbf{Fx}_{k-1}$ to get the predict new_x, which is:</p>

\[\begin{aligned}
\mathbf x_k &amp;=\begin{bmatrix}1&amp;\Delta t\\0&amp;1\end{bmatrix} \mathbf x_{k-1}
\end{aligned}\]

<p><strong>2. Covariance prediction:</strong>
In addition to predicting the state, itâ€™s essential to predict the covariance because the covariance matrix describes the uncertainty of the state estimation. We denote the predicted covariance matrix as $P_{k+1}$. There are two components in this part:</p>

<ol>
  <li>
    <p><strong>Impact of State Prediction on Covariance:</strong></p>

    <p>During the state prediction (predict) phase, the current state covariance matrix is updated to the predicted state covariance matrix using the state transition matrix F and the process noise covariance matrix ğ‘„. This step accounts for the uncertainty in state changes that the system model cannot fully capture.</p>
  </li>
  <li>
    <p><strong>Contribution of Process Noise:</strong></p>

    <p>The process noise covariance matrix Q plays a crucial role in the state prediction by describing the unmodeled dynamic changes in the system and the influence of control inputs. It directly affects the size and structure of the predicted state covariance matrix.</p>
  </li>
</ol>

<p>Based on these two factors, we predict the new state covariance matrix ( P ):</p>

\[\mathbf{P}_{k+1} = F \mathbf{P}_k F^T + Q\]

<p>Recall that Q describes the unmodeled dynamic changes in the system and the influence of control inputs, so it involves G and $\sigma_a^2$:</p>

\[\mathbf{Q} = G G^T \sigma^2_a\]

<p>To sum up:</p>

\[\mathbf{P}_{k+1} = F \mathbf{P}_k F^T + G G^T \sigma^2_a\]

<p>where  $\sigma^2_a $ is the variance of the acceleration noise.</p>

<p><strong>G</strong>
This prediction involves two main components:
For an object moving with constant acceleration a, the position change over a time interval dt can be expressed as:
\(x = x_0 + v_0 \cdot dt + \frac{1}{2} a \cdot dt^2\)</p>

<p>So that, <code class="language-plaintext highlighter-rouge">G[iX] = 0.5 * dt^2</code> and <code class="language-plaintext highlighter-rouge">G[iV] = dt</code> indicate the influence of acceleration noise on position and velocity over the time step $t$ and $G$ matrix is:
The process noise influence matrix ( $G$ ) is:</p>

\[G = \begin{pmatrix} 
0.5 \cdot dt^2 \\ 
dt 
\end{pmatrix}\]

<ul>
  <li>Process Noise Influence Matrix $G$:</li>
  <li>$G$ is the matrix describing the influence of process noise on the system state. Its size matches the state vector.</li>
  <li>The $G$ matrix considers the impact of acceleration noise on both position and velocity.</li>
  <li><code class="language-plaintext highlighter-rouge">G[iX] = 0.5 * dt^2</code> and <code class="language-plaintext highlighter-rouge">G[iV] = dt</code> indicate the influence of acceleration noise on position and velocity over the time step t.</li>
</ul>

<p>Using the G matrix, we predict the new state covariance matrix ( P ):</p>

\[\mathbf{P}_{k+1} = F \mathbf{P}_k F^T + G G^T \sigma^2_a\]

<p>where  $\sigma^2_a $ is the variance of the acceleration noise.</p>

<h4 id="step-4-update">Step 4 Update</h4>

<p>The update step is crucial because it allows the Kalman filter to correct its predictions based on new measurements. Imagine you have a system (like a moving car) and youâ€™re trying to estimate its position and speed. You use a model to predict where the car will be, but your prediction wonâ€™t be perfect due to uncertainties (like changes in speed or direction).</p>

<p>Every time you get a new measurement (like a GPS reading), you can use this new information to correct your estimate. This makes your estimation more accurate than just relying on predictions alone.</p>

<p>The update step of the Kalman filter utilizes linear algebra and probability theory to dynamically adjust the state estimate based on real-time measurement data. These mathematical formulas ensure that the filter optimally balances between the system dynamics and measurement uncertainties, providing accurate and reliable state estimation.</p>

<p>Thus, the update step involves correcting the predicted state estimate based on the new measurement. Hereâ€™s a detailed explanation of the update process:</p>

<ol>
  <li>
    <p><strong>Calculate Measurement Residual:</strong></p>

    <p>Calculate the measurement residual $y$ , which is the difference between the actual measurement $z$  and the predicted measurement based on the current state estimate</p>

\[y = z - H \mathbf{x}\]

    <p>where:</p>
    <ul>
      <li>$\mathbf{z}$ is the measured measurement.</li>
      <li>$\mathbf{H}$ is the observation matrix that maps the state vector into the measurement space.</li>
      <li>$\mathbf{x}$  is the predicted state vector.</li>
    </ul>
  </li>
  <li>
    <p><strong>Calculate Residual Covariance:</strong></p>

    <p>Compute the residual covariance $S$ , which combines the prediction uncertainty and measurement noise:</p>
  </li>
</ol>

\[S = H \mathbf{P} H^T + R\]

<p>where:</p>
<ul>
  <li>$\mathbf{P}$   is the predicted state covariance matrix.</li>
  <li>$\mathbf{R}$   is the covariance matrix of the measurement noise.</li>
</ul>

<ol>
  <li>
    <p><strong>Compute Kalman Gain:</strong></p>

    <p>The Kalman Gain is a factor that determines how much you should adjust your prediction based on the new measurement. It balances the uncertainty in your prediction against the uncertainty in the measurement. If your prediction is very uncertain but your measurement is very accurate, the Kalman Gain will be higher, meaning you trust the measurement more.
Calculate the Kalman gain $ K $, which determines how much the predicted state estimate is adjusted based on the measurement residual:</p>

\[K = \mathbf{P} H^T (H \mathbf{P} H^T + R)^{-1}\]
  </li>
  <li>
    <p><strong>Update State Estimate:</strong></p>

    <p>Update the state estimate  $\mathbf{x}$  using the Kalman gain and the measurement residual:</p>

\[\mathbf{x}^+ = \mathbf{x} + K y\]

    <p>Adjust your previous state estimate by adding the product of the Kalman Gain and the residual. This step corrects the prediction by bringing it closer to the actual measurement.</p>
  </li>
  <li>
    <p><strong>Update Covariance Matrix:</strong></p>

    <p>Update the covariance matrix $ \mathbf{P} $ to reflect the incorporation of new measurement information:</p>

\[\mathbf{P}^+ = (I - K H) \mathbf{P}\]
  </li>
</ol>

<h3 id="significance-in-applications">Significance in Applications</h3>

<p>The update step enables the Kalman filter to adaptively adjust the state estimate according to real-world measurement data, facilitating precise tracking and prediction of system states. This capability makes the Kalman filter invaluable in real-time applications such as navigation systems, robotics, and sensor data processing.</p>

<p><strong>Implementation of Update in Python:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">meas_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">meas_variance</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="c1"># y = z - H x
</span>        <span class="c1"># S = H P Ht + R
</span>        <span class="c1"># K = P Ht S^-1
</span>        <span class="c1"># x = x + K y
</span>        <span class="c1"># P = (I - K H) * P
</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]).</span><span class="nf">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">meas_value</span><span class="p">])</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">meas_variance</span><span class="p">])</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">H</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_x</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">H</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_P</span><span class="p">).</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span>

        <span class="n">K</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_P</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">T</span><span class="p">).</span><span class="nf">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">inv</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
        
        <span class="n">new_X</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">+</span> <span class="n">K</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">new_P</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">K</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">)).</span><span class="nf">dot</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_P</span><span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="n">_P</span> <span class="o">=</span> <span class="n">new_P</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">new_X</span>
</code></pre></div></div>

<h2 id="using-the-kf">Using the KF</h2>
<p>Now letâ€™s test the kalman filter implementation</p>

<p>We now create the <code class="language-plaintext highlighter-rouge">main.py</code> script to demonstrates how to use the Kalman Filter to track the position and velocity of an object over time.To better observe the performance of the Kalman Filter, we need to set up the plotting environment and initialize various parameters:</p>

<p><strong>1. Import Libraries and Modules and Set Plotting Environment:</strong></p>

<p>Import the necessary libraries and modules. numpy is used for numerical computations, matplotlib for plotting, and KF is the Kalman Filter implementation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="n">kf</span> <span class="kn">import</span> <span class="n">KF</span> 
</code></pre></div></div>

<p><strong>2. Initialization and Parameter Setup</strong></p>

<p>Initializing the real position and velocity of the object is necessary to simulate the actual state of the system we want to track. This provides a reference to compare against the filterâ€™s estimates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">real_x</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">meas_variance</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">real_v</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">kf</span> <span class="o">=</span> <span class="nc">KF</span><span class="p">(</span><span class="n">initial_x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">initial_v</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">accel_variance</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>3. Simulation Parameters</strong></p>

<p>Defining the noise in the measurements simulates real-world sensor inaccuracies. This helps in testing the filterâ€™s ability to handle and correct noisy data.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DT</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">NUM_STEPS</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">MEAS_EVERY_STEPS</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">mus</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">covs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">real_xs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">real_vs</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DT</code> is the time step, controlling the interval at which the simulation updates.</li>
  <li><code class="language-plaintext highlighter-rouge">NUM_STEPS</code> is the total number of steps to simulate, determining the duration of the simulation.</li>
  <li><code class="language-plaintext highlighter-rouge">MEAS_EVERY_STEPS</code> defines how often we take measurements, simulating periodic sensor readings.</li>
  <li><code class="language-plaintext highlighter-rouge">mus</code>, <code class="language-plaintext highlighter-rouge">covs</code>, <code class="language-plaintext highlighter-rouge">real_xs</code>, and <code class="language-plaintext highlighter-rouge">real_vs</code> are lists to store the filterâ€™s estimates, covariances, and the true positions and velocities for later analysis and plotting.</li>
</ul>

<p><strong>4. Simulation Loop</strong></p>

<p>To emulate the dynamic behavior of the system over time and to observe how the Kalman Filter performs in real-time tracking of the objectâ€™s state, we use simulation loop.  Hereâ€™s a detailed explanation of why we need the simulation loop:</p>
<ul>
  <li><strong>Dynamic Behavior Simulation:</strong> 
  In real-world applications, the state of the system (such as the position and velocity of an object) changes continuously over time. The simulation loop allows us to replicate this dynamic behavior in a controlled environment, updating the state of the system at each time step.</li>
  <li><strong>State Prediction and Update:</strong>
  The Kalman Filter operates in two main steps: prediction and update. The simulation loop enables these steps to be executed repeatedly.</li>
  <li><strong>Performance Evaluation:</strong>
  By running the simulation loop over multiple iterations, we can observe how well the Kalman Filter tracks the systemâ€™s state over time. This helps in evaluating the filterâ€™s accuracy and responsiveness to changes in the system.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">NUM_STEPS</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
        <span class="n">real_v</span> <span class="o">*=</span> <span class="mf">0.9</span>

    <span class="n">covs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">kf</span><span class="p">.</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">mus</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">kf</span><span class="p">.</span><span class="n">mean</span><span class="p">)</span>
    
    <span class="n">real_x</span> <span class="o">=</span> <span class="n">real_x</span> <span class="o">+</span> <span class="n">DT</span> <span class="o">*</span> <span class="n">real_v</span>

    <span class="n">kf</span><span class="p">.</span><span class="nf">predict</span><span class="p">(</span><span class="n">dt</span> <span class="o">=</span> <span class="n">DT</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">%</span> <span class="n">MEAS_EVERY_STEPS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kf</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">meas_value</span> <span class="o">=</span> <span class="n">real_x</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">meas_variance</span><span class="p">),</span> 
                  <span class="n">meas_variance</span> <span class="o">=</span> <span class="n">meas_variance</span><span class="p">)</span>

    <span class="n">real_xs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">real_x</span><span class="p">)</span>
    <span class="n">real_vs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">real_v</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>5. Plotting</strong></p>

<p>To visually assess the Kalman Filterâ€™s performance in estimating dynamic system states from noisy measurements, plotting is indispensable. It provides a clear comparison between estimated and actual states, visualizes uncertainties, aids in performance evaluation, and facilitates debugging and optimization of the filter implementation.</p>

<p>Apart from the estimated and actual states, we also plot the Confidence Interval of the estimated position/velocity (mean Â± 2 standard deviations), which helps us understand the range within which the true velocity is likely to lie with a high degree of confidence. It reflects the uncertainty in our velocity estimation due to measurement variations and model assumptions. Plotting this interval alongside the estimated velocity (mu[1]) allows us to visualize the accuracy and reliability of our velocity predictions throughout the simulation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Position</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">mus</span><span class="p">],</span> <span class="sh">'</span><span class="s">g</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">real_xs</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">covs</span><span class="p">)],</span> <span class="sh">'</span><span class="s">r--</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">covs</span><span class="p">)],</span> <span class="sh">'</span><span class="s">r--</span><span class="sh">'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Velocity</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">mus</span><span class="p">],</span> <span class="sh">'</span><span class="s">g</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">real_vs</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">covs</span><span class="p">)],</span> <span class="sh">'</span><span class="s">r--</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">([</span><span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">cov</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">covs</span><span class="p">)],</span> <span class="sh">'</span><span class="s">r--</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="\assets\2024-07-18-KalmanFilter\kalman_filter.png" alt="Description of the image" width="500" height="320" /></p>

<ul>
  <li>
    <p><strong>The first subplot (top) titled â€˜Positionâ€™ displaysï¼š</strong></p>

    <ol>
      <li>Green solid line: Estimated position <code class="language-plaintext highlighter-rouge">mu[0]</code> from the Kalman filter.</li>
      <li>Blue solid line: Real position <code class="language-plaintext highlighter-rouge">real_xs</code>.</li>
      <li>Red dashed lines: Confidence interval of the estimated position <code class="language-plaintext highlighter-rouge">mean Â± 2 standard deviations</code>.</li>
    </ol>
  </li>
  <li>
    <p><strong>The second subplot (bottom) titled â€˜Velocityâ€™ displays:</strong></p>
    <ol>
      <li>Green solid line: Estimated position <code class="language-plaintext highlighter-rouge">mu[0]</code> from the Kalman filter.</li>
      <li>Blue solid line: Real velocity <code class="language-plaintext highlighter-rouge">real_vs</code>.</li>
      <li>Red dashed lines: Confidence interval of the estimated velocity <code class="language-plaintext highlighter-rouge">mean Â± 2 standard deviations</code>.</li>
    </ol>
  </li>
</ul>

<p><strong>Performance Evaluation:</strong></p>

<ul>
  <li>
    <p><strong>Position:</strong></p>

    <p>The predicted positions closely match the true values, indicating excellent performance of the Kalman filter in tracking the systemâ€™s position. Additionally, the confidence interval for the estimated velocity is narrow, suggesting high confidence in the velocity estimates and minimal deviation from the actual velocity values. However, there may be noticeable fluctuations near zero, possibly due to inaccuracies in the system model when the position is near stationary or at rest.</p>
  </li>
  <li>
    <p><strong>Velocity:</strong></p>

    <p>Regarding velocity, the predicted values closely approximate the true values overall. However, during changes in velocity, there are noticeable discrepancies. The confidence interval is broader compared to position, indicating lower confidence in velocity estimates and larger potential deviations from actual values. Similar to position, there are significant fluctuations around zero, which are more pronounced for velocity estimates than for position estimates.</p>
  </li>
</ul>

<p><strong>Conclusion</strong></p>

<p>The Kalman filter demonstrates strong performance in tracking the position of the object, with predictions closely matching the true values. The confidence interval for position estimation remains narrow, indicating high confidence in these predictions, except for fluctuations near zero where variability increases.    For velocity, while the Kalman filter accurately tracks changes, there are some deviations observed during rapid changes. The confidence interval for velocity estimates is high, suggesting lower uncertainty in velocity predictions. Same to the position prediction, around zero the fluctuations are more pronounced.  Overall, the Kalman filter effectively reduces noise and provides reliable state estimation for dynamic systems.</p>]]></content><author><name>true</name></author><category term="KalmanFilter" /><category term="StateEstimation" /><category term="Tutorial" /><summary type="html"><![CDATA[Kalman Filter]]></summary></entry><entry><title type="html">Computer Science fundamental</title><link href="http://localhost:4000/2024/07/18/Computer_Science.html" rel="alternate" type="text/html" title="Computer Science fundamental" /><published>2024-07-18T01:00:00+01:00</published><updated>2024-07-18T01:00:00+01:00</updated><id>http://localhost:4000/2024/07/18/Computer_Science</id><content type="html" xml:base="http://localhost:4000/2024/07/18/Computer_Science.html"><![CDATA[<p>Owner: Xiaofan SHEN
Tags: Infrastructure</p>

<h1 id="python">Python</h1>

<h3 id="variables"><strong>Variables</strong></h3>

<p>AÂ <strong>variable</strong>Â in a program acts like a container. It can be used to store a string, a number, or other kinds of data.</p>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/box-and-tangible-value-4-mol6CH.png" alt="box-and-tangible-value-4-mol6CH.png" /></p>

<p><strong>str1.find(str2)</strong></p>

<aside>
ğŸ’¡ **str1.find(str2)**

</aside>

<h1 id="parallelism">Parallelism</h1>

<ul>
  <li>When multiple workers can split up a problem without adding in coordination overhead,Â computer scientists sometimes call the problemÂ <strong>embarrassingly parallel</strong>.</li>
  <li></li>
</ul>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/Untitled.png" alt="Untitled" /></p>

<h2 id="pipelining">Pipelining</h2>

<p><strong>Pipelining</strong>Â is a form of parallelism where tasks are solved faster by having multiple tasksÂ simultaneously at various levels of completion.</p>

<p>Parallelism can improve performance by improvingÂ <strong>latency</strong>Â (the time that a task takes from beginning to end) or by improvingÂ <strong>throughput</strong>Â (the amount of tasks that can complete during a given interval of time).</p>

<h1 id="resource-tradeoffs"><strong>Resource Tradeoffs</strong></h1>

<p>Inexpensive computers can perform 3Â basic computations in a nanosecondÂ â€”Â thatâ€™s oneÂ (wildly oversimplified) way of describing what it means to be aÂ â€œ3Â GHzâ€Â computer.</p>

<h2 id="caching">Caching</h2>

<p><strong>Caching</strong>Â is a general problem-solving approachÂ that provides a much more flexible way of dealing with certain resource tradeoffs.</p>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/computer-processor-diagram-ULTlpu.png" alt="**Hardware caches**" /></p>

<p><strong>Hardware caches</strong></p>

<h2 id="api">API</h2>

<p>An API is an interface or menu that different programs can use to communicate with each other.</p>

<aside>
ğŸ’¡ AnÂ **interface**Â is an abstraction that manages complexityÂ by defining how toÂ **interact**Â with a process while hiding how the processÂ **actually**Â gets donLisLis

</aside>

<p><em>â€œå‘è†å¸‚é•¿éšè—çš„ä¿¡æ¯å…è®¸æ¡£æ¡ˆéƒ¨åœ¨ä¸æ‰“æ‰°è†å¸‚é•¿çš„æƒ…å†µä¸‹æ”¹å˜å…¶å·¥ä½œæ–¹å¼ã€‚è¿™æ˜¯ç•Œé¢æ„ä¹‰çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚â€</em></p>

<h2 id="binary-search">Binary Search</h2>

<p><strong>Bridges of KÃ¶nigsberg</strong></p>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/konigsberg-bridge_-simplified-w-nsew-2-xpQnkF.png" alt="konigsberg-bridge_-simplified-w-nsew-2-xpQnkF.png" /></p>

<p>å›¾ä¸­æ¯æ¡è¾¹éƒ½ç»è¿‡ä¸€æ¬¡çš„è·¯å¾„ç§°ä¸º<strong>æ¬§æ‹‰è·¯å¾„</strong>ã€‚</p>

<aside>
ğŸ’¡ ä¸€æ¡è·¯å¾„åªæœ‰ä¸€ä¸ªç«¯ç‚¹å’Œä¸€ä¸ªèµ·ç‚¹ï¼Œå› æ­¤å¦‚æœä¸€ä¸ªå›¾æœ‰ä¸¤ä¸ªä»¥ä¸Šçš„é¡¶ç‚¹ï¼Œä¸”è¿æ¥è¾¹çš„æ•°é‡ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆå°±ä¸å¯èƒ½å­˜åœ¨æ¬§æ‹‰è·¯å¾„ã€‚

</aside>

<aside>
ğŸ’¡ ç§»é™¤æŸ¯å°¼æ–¯å ¡çš„**ä»»ä½•ä¸€åº§**æ¡¥éƒ½åªç•™ä¸‹ä¸¤ä¸ªå…·æœ‰å¥‡æ•°æ¡è¿æ¥è¾¹çš„é¡¶ç‚¹ã€‚è¿™æ„å‘³ç€ç§»é™¤**ä»»ä½•**ä¸€åº§æ¡¥éƒ½å¯ä»¥å½¢æˆæ¬§æ‹‰è·¯å¾„ã€‚

</aside>

<h2 id="breadth-first-search--depth-first-search"><strong>Breadth-first search  Depth-first search</strong></h2>

<p>AÂ <strong>list</strong>Â is a data type for storing multiple items of the same type that are related and belong together.</p>

<h2 id="list">List</h2>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/diff-variable-names-okay-2TIHqg.png" alt="diff-variable-names-okay-2TIHqg.png" /></p>

<h2 id="pseudocode"><strong>pseudocode</strong></h2>

<p>Writing the logic of programs in English is calledÂ <strong>pseudocode</strong>.</p>

<p>AnÂ <strong>algorithm</strong>Â is a step by step process designed to achieve some outcome, and computers are the fastest machines ever conceived for carrying out step by step processes!</p>

<p>That means that the study of algorithms is a core aim of computer science, but their use transcends any one discipline.</p>

<p>Code worked or delivered</p>

<p>When a computer scientist says an algorithmÂ â€œworks,â€Â that doesnâ€™t just mean it promises to produce a correct result. It also has to deliver on that promise,Â <em>finish</em>, and produce the result, on every possible input.</p>

<p>Making sure an algorithm always finishes and produces a result is calledÂ <em>proving termination</em>, and it can be a little bit tricky!</p>

<p>Langtonâ€™s antã€Boolean</p>

<h2 id="aconditional-statementuses-a-boolean-expression-to-determine-the-code-that-is-run">AÂ <strong>conditional statement</strong>Â uses a Boolean expression to determine the code that is run.</h2>

<p>Dictionary</p>

<p><img src="Computer%20Science%20d1ebabbae65e4cd39543506166c5471f/Untitled%201.png" alt="Untitled" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cleaned_word = word.lower().strip(punctuation)
</code></pre></div></div>

<p>reader = open(â€˜data/jekyll.txtâ€™)
punctuation = â€˜.;,-â€œâ€™â€:?â€”â€˜!()_â€™</p>

<p>freq_dict = {}
for line in reader:
for word in line.split():
cleaned_word = word.lower().strip(punctuation)
if cleaned_word in freq_dict:
freq_dict[cleaned_word]+=1
else:
freq_dict[cleaned_word]=1</p>

<p>print(len(freq_dict))</p>

<h2 id="counter"><strong>Counter</strong></h2>]]></content><author><name>true</name></author><category term="Computer" /><category term="Science" /><category term="fundamental" /><summary type="html"><![CDATA[Owner: Xiaofan SHEN Tags: Infrastructure]]></summary></entry><entry><title type="html">Table-scale Dynamic Haptic feedback for virtual reality utilized an object-moving robot</title><link href="http://localhost:4000/2022/09/27/MSc_Project.html" rel="alternate" type="text/html" title="Table-scale Dynamic Haptic feedback for virtual reality utilized an object-moving robot" /><published>2022-09-27T01:00:00+01:00</published><updated>2022-09-27T01:00:00+01:00</updated><id>http://localhost:4000/2022/09/27/MSc_Project</id><content type="html" xml:base="http://localhost:4000/2022/09/27/MSc_Project.html"><![CDATA[<h3 id="introduction">Introduction</h3>
<p>This project introduces a system that provides a dynamic table-scale haptic feedback for virtual reality, by using a robot that can move one mug on the table to map three virtual mugs in virtual reality. 
<img src="/assets/2022-09-27-MSc_Project/structure.png" alt="Description of the image" width="400" height="220" /></p>

<h4 id="hardware">Hardware</h4>
<p>An accurate tracking system is essential for tracking objects in this project. A headset mounted display (HMD), two controllers, two lighthouse BASE stations, and two VIVE
trackers 2.0 made up the setup of the Vive System.
 <img src="/assets/2022-09-27-MSc_Project/trackingarea.png" alt="Description of the image" width="580" height="380" />
 <br />
By synchronizing information from the real and virtual worlds and giving commands to the robot, users can touch and lift objects in virtual content with their hands carrying the controller. When the user gives a demand to touch a specific mug, the robot is activated to reconfigure the real world. 
 <img src="/assets/photos/userthink.png" alt="Description of the image" width="560" height="360" />
Similarly, virtual contents also changes along with operation conducted to the real mug (such as moving it or lifting it by the user) to achieve a sense of reality.</p>

<h4 id="experiments">Experiments</h4>
<iframe type="text/html" width="100%" height="385" src="https://youtube.com/embed/uQ05KesgF34" frameborder="0"></iframe>]]></content><author><name>true</name></author><category term="Robotics" /><category term="VR" /><category term="Haptic" /><summary type="html"><![CDATA[Introduction This project introduces a system that provides a dynamic table-scale haptic feedback for virtual reality, by using a robot that can move one mug on the table to map three virtual mugs in virtual reality.]]></summary></entry><entry><title type="html">Face morping</title><link href="http://localhost:4000/2022/04/07/Face-morping.html" rel="alternate" type="text/html" title="Face morping" /><published>2022-04-07T01:00:00+01:00</published><updated>2022-04-07T01:00:00+01:00</updated><id>http://localhost:4000/2022/04/07/Face%20morping</id><content type="html" xml:base="http://localhost:4000/2022/04/07/Face-morping.html"><![CDATA[<p>This project â€˜face morphingâ€™ is divided into 7 parts to complete a smooth transfer video from two
faces;</p>
<ol>
  <li>â€˜dlibâ€™ face landmark detector is used to detect 68 landmarks on 2 images, as 68 landmarks are
not covering all the face, 20 landmarks are manually added, including 16 landmarks on the face,
while 4 points locates the background, so that the background could also transfer smoothly;</li>
  <li>the standard Delaunay Triangulation is used to visualize triangulation of vertices(landmarks);</li>
  <li>get the interpolating between image1 and image2 by applying
x int = (x img1 + ximg2)/2
y int = (y img1 + yimg2)/2</li>
  <li>Getting parameters of the affine warp when vertices of two triangle were given, and between
every pairs of corresponding triangles, Affine warp was estimated;</li>
  <li>Find the all coordinates which are inside the given triangle, and then a labeled image was created
by dividing face into parts;</li>
  <li>Get the in - between image for a given â€˜wâ€™</li>
  <li>Create the transfer video;</li>
</ol>

<iframe type="text/html" width="100%" height="385" src="https://www.youtube.com/embed/0kpqJpmSTOg" frameborder="0"></iframe>]]></content><author><name>true</name></author><category term="Robotics" /><category term="VR" /><category term="Haptic" /><summary type="html"><![CDATA[This project â€˜face morphingâ€™ is divided into 7 parts to complete a smooth transfer video from two faces; â€˜dlibâ€™ face landmark detector is used to detect 68 landmarks on 2 images, as 68 landmarks are not covering all the face, 20 landmarks are manually added, including 16 landmarks on the face, while 4 points locates the background, so that the background could also transfer smoothly; the standard Delaunay Triangulation is used to visualize triangulation of vertices(landmarks); get the interpolating between image1 and image2 by applying x int = (x img1 + ximg2)/2 y int = (y img1 + yimg2)/2 Getting parameters of the affine warp when vertices of two triangle were given, and between every pairs of corresponding triangles, Affine warp was estimated; Find the all coordinates which are inside the given triangle, and then a labeled image was created by dividing face into parts; Get the in - between image for a given â€˜wâ€™ Create the transfer video;]]></summary></entry><entry><title type="html">Immersive Virtual Reality Cooking Game</title><link href="http://localhost:4000/2022/03/01/VR-game.html" rel="alternate" type="text/html" title="Immersive Virtual Reality Cooking Game" /><published>2022-03-01T00:00:00+00:00</published><updated>2022-03-01T00:00:00+00:00</updated><id>http://localhost:4000/2022/03/01/VR%20game</id><content type="html" xml:base="http://localhost:4000/2022/03/01/VR-game.html"><![CDATA[<blockquote>
  <p>This project is an engaging VR game that created an elegant environment infused with Chinese elements in Unity. Multiple players collaborated to accomplish tasks, involving research for CC0 prefabs and/or models, environment design and building, teleportation, object scripts, menu display, ingredient handling, scoring system, upgrades, and rigorous testing.</p>
</blockquote>]]></content><author><name>Jekyll</name></author><category term="VR" /><category term="Game" /><summary type="html"><![CDATA[This project is an engaging VR game that created an elegant environment infused with Chinese elements in Unity. Multiple players collaborated to accomplish tasks, involving research for CC0 prefabs and/or models, environment design and building, teleportation, object scripts, menu display, ingredient handling, scoring system, upgrades, and rigorous testing.]]></summary></entry><entry><title type="html">A Power Optimized Method in Android Systems</title><link href="http://localhost:4000/2019/08/06/android-system.html" rel="alternate" type="text/html" title="A Power Optimized Method in Android Systems" /><published>2019-08-06T00:00:00+01:00</published><updated>2019-08-06T00:00:00+01:00</updated><id>http://localhost:4000/2019/08/06/android%20system</id><content type="html" xml:base="http://localhost:4000/2019/08/06/android-system.html"><![CDATA[<h2 id="abstract">Abstract</h2>

<p>How the Suspend/Resume mechanism of smartphone influences the power consumption is examined in the dissertation. Specifically, various unimportant and not so urgent network packets keep awakening the operating system (OS) at the time it is under suspend mode, and switch it from suspend to resume mode
continually, which results in more power consumption. Accordingly, an innovative optimization technique was suggested in this paper in order that the awakening of OS can be postponed and the lasting hour of suspend mode can be lengthened to decrease power consumption. Some experiments are also carried out, with
the result data suggesting that such technique is an effective way to reduce power consumption by greater than 7.63%. It proves that this technique is workable.</p>]]></content><author><name>Jekyll</name></author><category term="Article" /><summary type="html"><![CDATA[Abstract]]></summary></entry></feed>